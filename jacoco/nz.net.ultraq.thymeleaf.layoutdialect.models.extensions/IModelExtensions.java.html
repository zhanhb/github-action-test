<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IModelExtensions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Thymeleaf Layout Dialect</a> &gt; <a href="index.source.html" class="el_package">nz.net.ultraq.thymeleaf.layoutdialect.models.extensions</a> &gt; <span class="el_source">IModelExtensions.java</span></div><h1>IModelExtensions.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016, Emanuel Rabina (http://www.ultraq.net.nz/)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nz.net.ultraq.thymeleaf.layoutdialect.models.extensions;

import org.thymeleaf.model.*;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * Meta-programming extensions to the {@link IModel} class.
 *
 * @author zhanhb
 * @author Emanuel Rabina
 */
<span class="nc" id="L36">public class IModelExtensions {</span>

	/**
	 * Set that a model evaluates to 'false' if it has no events.
	 *
	 * @param self
	 * @return {@code true} if this model has events.
	 */
	public static boolean asBoolean(@Nullable IModel self) {
<span class="fc bfc" id="L45" title="All 4 branches covered.">		return self != null &amp;&amp; self.size() &gt; 0;</span>
	}

	/**
	 * If this model represents an element, then this method returns an iterator
	 * over any potential child items as models of their own.
	 *
	 * @param self
	 * @return New model iterator.
	 */
	@Nullable
	public static Iterator&lt;IModel&gt; childModelIterator(@Nonnull IModel self) {
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">		return isElement(self) ? new ChildModelIterator(self) : null;</span>
	}

	/**
	 * Iterate through each event in the model.
	 *
	 * @param self
	 * @param closure
	 */
	public static void each(@Nullable IModel self, @Nonnull Consumer&lt;ITemplateEvent&gt; closure) {
<span class="fc" id="L67">		Iterator&lt;ITemplateEvent&gt; it = maskNull(self);</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">		while (it.hasNext()) {</span>
<span class="fc" id="L69">			closure.accept(it.next());</span>
		}
<span class="fc" id="L71">	}</span>

	/**
	 * Compare 2 models, returning {@code true} if all of the model's events are
	 * equal.
	 *
	 * @param self
	 * @param other
	 * @return {@code true} if this model is the same as the other one.
	 */
	public static boolean equals(IModel self, Object other) {
<span class="pc bpc" id="L82" title="2 of 4 branches missed.">		if (self != null &amp;&amp; other instanceof IModel) {</span>
<span class="fc" id="L83">			IModel iModel = (IModel) other;</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">			if (self.size() == iModel.size()) {</span>
<span class="fc" id="L85">				return everyWithIndex(self, (event, index) -&gt; ITemplateEventExtensions.equals(event, iModel.get(index)));</span>
			}
		}
<span class="nc" id="L88">		return false;</span>
	}

	/**
	 * Return {@code true} only if all the events in the model return
	 * {@code true} for the given closure.
	 *
	 * @param self
	 * @param closure
	 * @return {@code true} if every event satisfies the closure.
	 */
	public static boolean everyWithIndex(@Nullable IModel self, @Nonnull BiPredicate&lt;ITemplateEvent, Integer&gt; closure) {
<span class="fc" id="L100">		int index = 0;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">		for (Iterator&lt;ITemplateEvent&gt; it = maskNull(self); it.hasNext(); ++index) {</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">			if (!closure.test(it.next(), index)) {</span>
<span class="nc" id="L103">				return false;</span>
			}
		}
<span class="fc" id="L106">		return true;</span>
	}

	/**
	 * Returns the first event in the model that meets the criteria of the given
	 * closure.
	 *
	 * @param self
	 * @param closure
	 * @return The first event to match the closure criteria, or {@code null} if
	 * nothing matched.
	 */
	@Nullable
	public static ITemplateEvent find(@Nullable IModel self, @Nonnull Predicate&lt;ITemplateEvent&gt; closure) {
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">		for (Iterator&lt;ITemplateEvent&gt; it = maskNull(self); it.hasNext(); ) {</span>
<span class="fc" id="L121">			ITemplateEvent event = it.next();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">			if (closure.test(event)) {</span>
<span class="fc" id="L123">				return event;</span>
			}
<span class="fc" id="L125">		}</span>
<span class="nc" id="L126">		return null;</span>
	}

	/**
	 * Find all events in the model that match the given closure.
	 *
	 * @param self
	 * @param closure
	 * @return A list of matched events.
	 */
	@Nonnull
	public static List&lt;ITemplateEvent&gt; findAll(@Nullable IModel self, @Nonnull Predicate&lt;ITemplateEvent&gt; closure) {
		@SuppressWarnings(&quot;CollectionWithoutInitialCapacity&quot;)
<span class="nc" id="L139">		ArrayList&lt;ITemplateEvent&gt; answer = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">		for (Iterator&lt;ITemplateEvent&gt; it = maskNull(self); it.hasNext(); ) {</span>
<span class="nc" id="L141">			ITemplateEvent event = it.next();</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">			if (closure.test(event)) {</span>
<span class="nc" id="L143">				answer.add(event);</span>
			}
<span class="nc" id="L145">		}</span>
<span class="nc" id="L146">		return answer;</span>
	}

	/**
	 * Returns the index of the first event in the model that meets the criteria
	 * of the given closure.
	 *
	 * @param self
	 * @param closure
	 * @return The index of the first event to match the closure criteria, or
	 * {@code -1} if nothing matched.
	 */
	public static int findIndexOf(@Nonnull IModel self, @Nonnull Predicate&lt;ITemplateEvent&gt; closure) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">		for (int i = 0, size = self.size(); i &lt; size; i++) {</span>
<span class="fc" id="L160">			ITemplateEvent event = self.get(i);</span>
<span class="fc" id="L161">			boolean result = closure.test(event);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">			if (result) {</span>
<span class="fc" id="L163">				return i;</span>
			}
		}
<span class="fc" id="L166">		return -1;</span>
	}

	/**
	 * A special variant of {@code findIndexOf} that uses models, as I seem to
	 * be using those a lot.
	 * &lt;p&gt;
	 * This doesn't use an equality check, but an object reference check, so if
	 * a submodel is ever located from a parent (eg: any of the {@code find}
	 * methods, you can use this method to find the location of that submodel
	 * within the event queue.
	 *
	 * @param self
	 * @param model
	 * @return Index of an extracted submodel within this model.
	 */
	public static int findIndexOfModel(@Nonnull IModel self, IModel model) {
<span class="fc" id="L183">		ITemplateEvent modelEvent = first(model);</span>
<span class="fc" id="L184">		return findIndexOf(self, event -&gt; ITemplateEventExtensions.equals(event, modelEvent));</span>
	}

	/**
	 * Returns the first instance of a model that meets the given closure
	 * criteria.
	 *
	 * @param self
	 * @param closure
	 * @return A model over the event that matches the closure criteria, or
	 * {@code null} if nothing matched.
	 */
	public static IModel findModel(@Nonnull IModel self, @Nonnull Predicate&lt;ITemplateEvent&gt; closure) {
<span class="fc" id="L197">		return getModel(self, findIndexOf(self, closure));</span>
	}

	/**
	 * Returns the first event on the model.
	 *
	 * @param self
	 * @return The model's first event.
	 */
	public static ITemplateEvent first(@Nonnull IModel self) {
<span class="fc" id="L207">		return self.get(0);</span>
	}

	/**
	 * Returns the model at the given index. If the event at the index is an
	 * opening element, then the returned model will consist of that element and
	 * all the way through to the matching closing element.
	 *
	 * @param self
	 * @param pos  A valid index within the current model.
	 * @return Model at the given position, or `null` if the position is outside
	 * of the event queue.
	 */
	@Nullable
	@SuppressWarnings({&quot;ValueOfIncrementOrDecrementUsed&quot;, &quot;AssignmentToMethodParameter&quot;})
	public static IModel getModel(@Nonnull IModel self, int pos) {
<span class="fc bfc" id="L223" title="All 4 branches covered.">		if (0 &lt;= pos &amp;&amp; pos &lt; self.size()) {</span>
<span class="fc" id="L224">			IModel result = self.getConfiguration()</span>
<span class="fc" id="L225">				.getModelFactory(self.getTemplateMode())</span>
<span class="fc" id="L226">				.createModel();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">			for (int size = sizeOfModelAt(self, pos); size-- &gt; 0; ++pos) {</span>
<span class="fc" id="L228">				result.add(self.get(pos));</span>
			}
<span class="fc" id="L230">			return result;</span>
		}
<span class="fc" id="L232">		return null;</span>
	}

	/**
	 * Inserts a model, creating whitespace events around it so that it appears in
	 * line with all the existing events.
	 * &lt;p&gt;
	 * This is currently only targeting uses in the layout dialect so doesn't work
	 * very well as a general-purpose whitespace generator.
	 *
	 * @param self
	 * @param pos          A valid index within the current model.
	 * @param model
	 * @param modelFactory
	 */
	@SuppressWarnings(&quot;null&quot;)
	public static void insertModelWithWhitespace(
		@Nonnull IModel self, int pos,
		@Nullable IModel model, @Nonnull IModelFactory modelFactory) {

<span class="pc bpc" id="L252" title="1 of 4 branches missed.">		if (0 &lt;= pos &amp;&amp; pos &lt;= self.size()) {</span>

			// Derive the amount of whitespace to apply by finding the first
			// whitespace event before the insertion point.  Defaults to a single tab.
<span class="fc" id="L256">			String whitespace = &quot;\t&quot;;</span>
<span class="pc bpc" id="L257" title="1 of 2 branches missed.">			if (pos &gt; 0) {</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">				for (int i = pos - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L259">					ITemplateEvent event = self.get(i);</span>
<span class="fc bfc" id="L260" title="All 4 branches covered.">					if (ITemplateEventExtensions.isWhitespace(event) &amp;&amp; !((IText) event).getText().isEmpty()) {</span>
<span class="fc" id="L261">						whitespace = ((IText) event).getText().replaceAll(&quot;[\r\n]&quot;, &quot;&quot;);</span>
<span class="fc" id="L262">						break;</span>
					}
				}
			}

			// Insert an extra whitespace event for when adding to an immediately-closed
			// element, eg: &lt;div&gt;&lt;/div&gt;
<span class="pc bpc" id="L269" title="1 of 6 branches missed.">			if (pos &gt; 0 &amp;&amp; self.get(pos - 1) instanceof IOpenElementTag &amp;&amp; self.get(pos) instanceof ICloseElementTag) {</span>
<span class="fc" id="L270">				self.insertModel(pos, modelFactory.createModel(modelFactory.createText(System.lineSeparator())));</span>
			}
<span class="fc" id="L272">			self.insertModel(pos, model);</span>
<span class="fc" id="L273">			self.insertModel(pos, modelFactory.createModel(modelFactory.createText(System.lineSeparator() + whitespace)));</span>
		}
<span class="fc" id="L275">	}</span>

	/**
	 * Inserts an event, creating a whitespace event before it so that it
	 * appears in line with all the existing events.
	 *
	 * @param self
	 * @param pos          A valid index within the current model.
	 * @param event
	 * @param modelFactory
	 */
	@SuppressWarnings(&quot;null&quot;)
	public static void insertWithWhitespace(
		@Nonnull IModel self, int pos,
		@Nullable ITemplateEvent event, @Nonnull IModelFactory modelFactory) {

<span class="pc bpc" id="L291" title="2 of 4 branches missed.">		if (0 &lt;= pos &amp;&amp; pos &lt;= self.size()) {</span>

			// TODO: Because I can't check the parent for whitespace hints, I should
			//       make this smarter and find whitespace within the model to copy.
<span class="fc" id="L295">			IModel whitespace = getModel(self, pos); // Assumes that whitespace exists at the insertion point</span>
<span class="pc bpc" id="L296" title="1 of 4 branches missed.">			if (asBoolean(whitespace) &amp;&amp; isWhitespace(whitespace)) {</span>
<span class="nc" id="L297">				self.insert(pos, event);</span>
<span class="nc" id="L298">				self.insertModel(pos, whitespace);</span>
			} else {
<span class="fc" id="L300">				IText newLine = modelFactory.createText(&quot;\n&quot;);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">				if (pos == 0) {</span>
<span class="fc" id="L302">					self.insert(pos, newLine);</span>
<span class="fc" id="L303">					self.insert(pos, event);</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">				} else if (pos == self.size()) {</span>
<span class="fc" id="L305">					self.insert(pos, newLine);</span>
<span class="fc" id="L306">					self.insert(pos, event);</span>
<span class="fc" id="L307">					self.insert(pos, newLine);</span>
				}
			}
		}
<span class="fc" id="L311">	}</span>

	/**
	 * Returns whether or not this model represents a single HTML element.
	 *
	 * @param self
	 * @return {@code true} if the first event in this model is an opening tag
	 * and the last event is the matching closing tag.
	 */
	public static boolean isElement(@Nonnull IModel self) {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">		return sizeOfModelAt(self, 0) == self.size();</span>
	}

	/**
	 * Returns whether or not this model represents collapsible whitespace.
	 *
	 * @param self
	 * @return {@code true} if this is a collapsible text model.
	 */
	public static boolean isWhitespace(@Nonnull IModel self) {
<span class="fc bfc" id="L331" title="All 4 branches covered.">		return self.size() == 1 &amp;&amp; ITemplateEventExtensions.isWhitespace(first(self));</span>
	}

	/**
	 * Used to make this class iterable as an event queue.
	 *
	 * @param self
	 * @return A new iterator over the events of this model.
	 */
	@Nonnull
	public static Iterator&lt;ITemplateEvent&gt; iterator(@Nonnull IModel self) {
<span class="fc" id="L342">		return new EventIterator(self);</span>
	}

	private static Iterator&lt;ITemplateEvent&gt; maskNull(@Nullable IModel self) {
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">		Iterator&lt;ITemplateEvent&gt; result = self != null ? iterator(self) : null;</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">		return result != null ? result : Collections.emptyIterator();</span>
	}

	/**
	 * Returns the last event on the model.
	 *
	 * @param self
	 * @return The model's last event.
	 */
	public static ITemplateEvent last(@Nonnull IModel self) {
<span class="fc" id="L357">		return self.get(self.size() - 1);</span>
	}

	/**
	 * Remove a model identified by an event matched by the given closure.  Note
	 * that this closure can match any event in the model, including the top-level
	 * model itself.
	 *
	 * @param self
	 * @param closure
	 */
	public static void removeAllModels(
		@Nonnull IModel self,
		Predicate&lt;ITemplateEvent&gt; closure) {
		while (true) {
<span class="fc" id="L372">			int modelIndex = findIndexOf(self, closure);</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">			if (modelIndex == -1) {</span>
<span class="fc" id="L374">				return;</span>
			}
<span class="fc" id="L376">			removeModel(self, modelIndex);</span>
<span class="fc" id="L377">		}</span>
	}

	/**
	 * If the model represents an element open to close tags, then this method
	 * removes all of the inner events.
	 *
	 * @param self
	 */
	public static void removeChildren(@Nonnull IModel self) {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">		if (isElement(self)) {</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">			while (self.size() &gt; 2) {</span>
<span class="fc" id="L389">				self.remove(1);</span>
			}
		}
<span class="fc" id="L392">	}</span>

	/**
	 * Removes the first event on the model.
	 *
	 * @param self
	 */
	public static void removeFirst(@Nonnull IModel self) {
<span class="nc" id="L400">		self.remove(0);</span>
<span class="nc" id="L401">	}</span>

	/**
	 * Removes the last event on the model.
	 *
	 * @param self
	 */
	public static void removeLast(@Nonnull IModel self) {
<span class="fc" id="L409">		self.remove(self.size() - 1);</span>
<span class="fc" id="L410">	}</span>

	/**
	 * Removes a models-worth of events from the specified position. What this
	 * means is that, if the event at the position is an opening element, then
	 * it, and everything up to and including its matching end element, is
	 * removed.
	 *
	 * @param self
	 * @param pos  A valid index within the current model.
	 */
	public static void removeModel(@Nonnull IModel self, int pos) {
<span class="pc bpc" id="L422" title="2 of 4 branches missed.">		if (0 &lt;= pos &amp;&amp; pos &lt; self.size()) {</span>
<span class="fc" id="L423">			int modelSize = sizeOfModelAt(self, pos);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">			while (modelSize &gt; 0) {</span>
<span class="fc" id="L425">				self.remove(pos);</span>
<span class="fc" id="L426">				modelSize--;</span>
			}
		}
<span class="fc" id="L429">	}</span>

	/**
	 * Replaces the model at the specified index with the given model.
	 *
	 * @param self
	 * @param pos   A valid index within the current model.
	 * @param model
	 */
	public static void replaceModel(@Nonnull IModel self, int pos, @Nullable IModel model) {
<span class="pc bpc" id="L439" title="2 of 4 branches missed.">		if (0 &lt;= pos &amp;&amp; pos &lt; self.size()) {</span>
<span class="fc" id="L440">			removeModel(self, pos);</span>
			// noop if model is null
			// https://github.com/thymeleaf/thymeleaf/blob/thymeleaf-3.0.11.RELEASE/src/main/java/org/thymeleaf/engine/Model.java#L206
<span class="fc" id="L443">			self.insertModel(pos, model);</span>
		}
<span class="fc" id="L445">	}</span>

	/**
	 * If an opening element exists at the given position, this method will
	 * return the 'size' of that element (number of events from here to its
	 * matching closing tag).
	 *
	 * @param self
	 * @param index
	 * @return Size of an element from the given position, or 1 if the event at
	 * the position isn't an opening element.
	 */
	@SuppressWarnings(&quot;ValueOfIncrementOrDecrementUsed&quot;)
	public static int sizeOfModelAt(@Nonnull IModel self, int index) {
<span class="fc" id="L459">		int eventIndex = index;</span>
<span class="fc" id="L460">		ITemplateEvent event = self.get(eventIndex++);</span>

<span class="fc bfc" id="L462" title="All 2 branches covered.">		if (event instanceof IOpenElementTag) {</span>
<span class="fc" id="L463">			int level = 0;</span>
			while (true) {
<span class="fc" id="L465">				event = self.get(eventIndex++);</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">				if (event instanceof IOpenElementTag) {</span>
<span class="fc" id="L467">					level++;</span>
<span class="fc bfc" id="L468" title="All 2 branches covered.">				} else if (event instanceof ICloseElementTag) {</span>
					//noinspection StatementWithEmptyBody
<span class="fc bfc" id="L470" title="All 2 branches covered.">					if (((ICloseElementTag) event).isUnmatched()) {</span>
						// Do nothing.  Unmatched closing tags do not correspond to any
						// opening element, and so should not affect the model level.
<span class="fc bfc" id="L473" title="All 2 branches covered.">					} else if (level == 0) {</span>
<span class="fc" id="L474">						break;</span>
					} else {
<span class="fc" id="L476">						level--;</span>
					}
				}
			}
<span class="fc" id="L480">			return eventIndex - index;</span>
		}

<span class="fc" id="L483">		return 1;</span>
	}

	/**
	 * Removes whitespace events from the head and tail of the model's
	 * underlying event queue.
	 *
	 * @param self
	 */
	public static void trim(@Nonnull IModel self) {
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">		while (ITemplateEventExtensions.isWhitespace(first(self))) {</span>
<span class="nc" id="L494">			removeFirst(self);</span>
		}
<span class="fc bfc" id="L496" title="All 2 branches covered.">		while (ITemplateEventExtensions.isWhitespace(last(self))) {</span>
<span class="fc" id="L497">			removeLast(self);</span>
		}
<span class="fc" id="L499">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>